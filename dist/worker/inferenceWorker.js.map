{"version":3,"sources":["../../src/worker/inferenceWorker.ts"],"names":[],"mappings":";AAkBA,IAAI,KAAA,GAAQ,KAAA;AACZ,IAAI,SAAA,GAAY,CAAA;AAEhB,IAAA,CAAK,SAAA,GAAY,OAAO,EAAA,KAAqC;AAC3D,EAAA,IAAI;AACF,IAAA,MAAM,MAAM,EAAA,CAAG,IAAA;AACf,IAAA,QAAQ,IAAI,IAAA;AAAM,MAChB,KAAK,MAAA,EAAQ;AAGX,QAAA,KAAA,GAAQ,IAAA;AACR,QAAC,IAAA,CAAa,WAAA,CAAY,EAAE,IAAA,EAAM,SAAS,CAAA;AAC3C,QAAA;AAAA,MACF;AAAA,MACA,KAAK,UAAA,EAAY;AACf,QAAA,IAAI,CAAC,KAAA,EAAO,MAAM,IAAI,MAAM,wBAAwB,CAAA;AACpD,QAAA,SAAA,GAAY,YAAY,GAAA,EAAI;AAE5B,QAAA,MAAM,GAAA,GAAM,IAAI,OAAA,CAAQ,QAAA;AACxB,QAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,CAAI,QAAQ,CAAA,EAAA,EAAK;AACnC,UAAA,IAAI,MAAM,CAAA,EAAG;AACX,YAAC,IAAA,CAAa,WAAA,CAAY,EAAE,IAAA,EAAM,SAAS,OAAA,EAAS,GAAA,CAAI,CAAC,CAAA,EAAG,MAAA,EAAQ,WAAA,CAAY,GAAA,EAAI,GAAI,WAAW,CAAA;AAAA,UACrG,CAAA,MAAO;AACL,YAAC,IAAA,CAAa,YAAY,EAAE,IAAA,EAAM,SAAS,OAAA,EAAS,GAAA,CAAI,CAAC,CAAA,EAAG,CAAA;AAAA,UAC9D;AACA,UAAA,MAAM,IAAI,OAAA,CAAQ,CAAC,MAAM,UAAA,CAAW,CAAA,EAAG,EAAE,CAAC,CAAA;AAAA,QAC5C;AACA,QAAC,IAAA,CAAa,WAAA,CAAY,EAAE,IAAA,EAAM,QAAQ,CAAA;AAC1C,QAAA;AAAA,MACF;AAAA,MACA,KAAK,SAAA,EAAW;AACd,QAAA,KAAA,EAAM;AACN,QAAA;AAAA,MACF;AAAA;AACF,EACF,SAAS,CAAA,EAAQ;AACf,IAAC,IAAA,CAAa,WAAA,CAAY,EAAE,IAAA,EAAM,OAAA,EAAS,OAAA,EAAS,CAAA,EAAG,OAAA,IAAW,MAAA,CAAO,CAAC,CAAA,EAAG,CAAA;AAAA,EAC/E;AACF,CAAA","file":"inferenceWorker.js","sourcesContent":["// Minimal worker wiring for WASM placeholder path\nexport type WorkerInit = {\n  modelBuffers: ArrayBuffer[]; // shards\n  tokenizerBytes?: ArrayBuffer;\n  plan: { engine: 'wasm' | 'webgpu' | 'webnn'; quant: string; ctx: number };\n};\n\nexport type WorkerCommands =\n  | { type: 'init'; payload: WorkerInit }\n  | { type: 'generate'; payload: { inputIds: number[]; opts: any } }\n  | { type: 'dispose' };\n\nexport type WorkerEvents =\n  | { type: 'ready' }\n  | { type: 'token'; tokenId: number; ttfbMs?: number }\n  | { type: 'done' }\n  | { type: 'error'; message: string };\n\nlet ready = false;\nlet ttfbStart = 0;\n\nself.onmessage = async (ev: MessageEvent<WorkerCommands>) => {\n  try {\n    const msg = ev.data;\n    switch (msg.type) {\n      case 'init': {\n        // TODO: load WASM / WebGPU kernels based on plan\n        // For now, pretend to initialize\n        ready = true;\n        (self as any).postMessage({ type: 'ready' });\n        break;\n      }\n      case 'generate': {\n        if (!ready) throw new Error('Worker not initialized');\n        ttfbStart = performance.now();\n        // Placeholder: echo tokens with small delay\n        const ids = msg.payload.inputIds;\n        for (let i = 0; i < ids.length; i++) {\n          if (i === 0) {\n            (self as any).postMessage({ type: 'token', tokenId: ids[i], ttfbMs: performance.now() - ttfbStart });\n          } else {\n            (self as any).postMessage({ type: 'token', tokenId: ids[i] });\n          }\n          await new Promise((r) => setTimeout(r, 10));\n        }\n        (self as any).postMessage({ type: 'done' });\n        break;\n      }\n      case 'dispose': {\n        close();\n        break;\n      }\n    }\n  } catch (e: any) {\n    (self as any).postMessage({ type: 'error', message: e?.message ?? String(e) });\n  }\n};\n\n\n"]}